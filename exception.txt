1.Is there any way to "get around" the strict restrictions placed on methods by the throws clause?
 Yes. This is almost never the case ,because the right solution is to redesign the methods. However, that for some reason a system class has you in a straitjacket. 
to make the subclass RuntimeException as exempt exception because the throws clause that was annoying does not need to include this new exception. 



2.Differences between exceptions, errors, and runtime exceptions?

RUNN TIME EXCEPTIONS:

The classes that extend RuntimeException are known as unchecked exceptions.
Unchecked exceptions are not checked at compile-time rather they are checked at runtime and thats why they are also called "Runtime Exception"
They are also programmatically recoverable problems but unlike checked exception they are caused by faults in code flow or configuration.
Example:  ArithmeticException,NullPointerException, ArrayIndexOutOfBoundsException etc
Since they are programming error, they can be avoided by nicely/wisely coding. For example "dividing by zero" occurs ArithmeticEceeption. We can avoid them by a simple if condition - if(divisor!=0). Similarly we can avoid NullPointerException by simply checking the references - if(object!=null) or using even better techniques


ERRORS:

Error refers irrecoverable situation that are not being handled by try/catch
Example: OutOfMemoryError, VirtualMachineError, AssertionError etc.



Just as checked exceptions are useful for signaling when your methods cannot fulfill their contract, there are other errors outside of 
your control that can occur that prevent the Java virtual machine from fulfilling its specification, such as when memory is exhausted.
Since you can't plan for such errors ahead of time, you would have to catch them everywhere, which defeats the principle of maintaining uncluttered code.
Therefore, these errors are unchecked exceptions, meaning exceptions that you don't have to include in a throws clause.
Unchecked exceptions fall into two categories: those that extend RuntimeException, and those that extend Error. 
I realize that I said earlier that classes inheriting from class Exception are checked exceptions, but that's only half true: 
the whole truth is that classes in the Exception hierarchy other than those in the RuntimeException sub-hierarchy are checked exceptions.
 
EXCEPTIONS:

Exceptions that extend RuntimeException represent errors that you may want to handle, although  not required to.

Errors are caused by dynamic linking, or virtual machine problems, and are thus too low-level for most programs to care about-or be able to handle 
even if they did care about them. Runtime exceptions are generated by the normal execution of Java code, and although they occasionally reflect a condition you
will want to handle explicitly, more often they reflect a coding mistake by the programmer and thus simply need to print an error to help flag that mistake. 
Exceptions that are not runtime exceptions (IOException exceptions, for example) are conditions that, because of their nature, 
should be explicitly handled by any robust and well-thought-out code. The Java class library has been written using only a few of these, 
but those few are extremely important to using the system safely and correctly. The compiler helps you handle these exceptions properly via its throws clause 
checks and restrictions.